{
  lib,
  inputs,
}: let
  args = inputs;
  capacitate = lib.capacitor.capacitate;
  self = capacitate.capacitate;
in
  ###
  # Closure:
  # Metadata attached to a proto* function.
  # Capacitor enumerates all proto* functions in a flake
  # and adds additional data to them.
  # Evaluating the closures means evaluating the proto* function
  # with a standardized context that is a superset of the closure.
  #
  # closure:: {
  #   system,         # the system the closure is defined for
  #   flakePath,      # path to the flake in the import graph
  #   isCapacitated,  # whether the closure was generated by capacitor (const = true)
  #   type,           # the proto type (const = "proto")
  #   outerPath       # attrpath of the original proto
  #   fn              # the proto function
  #   outputType      # the anticipated type of the proto (generally, the flake attribute)
  #   namespace       # the normalized attribute path of the proto value after evaluation
  #   value           # the value for the proto* function after evaluation with `context`
  # }
  #
  # Context:; closure âˆª {
  #   lib = lib // self.root.lib;
  #   args            # arguments to the flake
  #   args'
  #   inputs = args';
  #   self' = self.instantiate system flakeArgs.self;
  #   self = flakeArgs.self;
  #   root =  self.root;
  #   root' = self.rootWith system;
  #   nixpkgs' = self.nixpkgsWith system;
  #   nixpkgs = self.nixpkgs;
  #   pkgs = self.nixpkgsWith system;
  #   withRev = version: "${version}-r${toString flakeArgs.self.revCount or "dirty"}";
  # }
  #
  #
  ###
  {
    protoToClosure = {
      systems,
      flakePath ? [],
      # outputType,
      ...
    } @ defaults: {
      type,
      isCapacitated,
      outerPath,
      fn,
    } @ closure: let
      hasSystem =
        if lib.length outerPath == 0
        then false
        else lib.elem (lib.head outerPath) lib.platforms.all;
      namespace =
        if lib.length outerPath == 0 || (hasSystem && lib.length outerPath == 1)
        then ["default"]
        else if hasSystem
        then (lib.tail outerPath)
        else outerPath;

      # if has System only use the specified one
      # else instantiate for all systems
      systems =
        if hasSystem
        then [(lib.head outerPath)]
        else defaults.systems;

      systemlessClosure =
        closure
        // {
          inherit namespace flakePath;
          # inherit outputType;
        }
        // {
          fn = {
            __toString = self: "<<Proto Derivation>>";
            __functor = self: closure.fn;
          };
        };

      closuresForEachSystem =
        map
        (system: systemlessClosure // {inherit system;})
        systems;
    in
      if systems != []
      then closuresForEachSystem
      else [systemlessClosure];

    collectProtos = set: let
      collect = {
        path ? [],
        setOrProto,
      }:
      # [sic]
        if builtins.isFunction setOrProto
        then [
          {
            type = "proto";
            isCapacitated = true;
            outerPath = path;
            fn = setOrProto;
          }
        ]
        else if lib.isAttrs setOrProto
        then
          lib.concatMap collect
          (lib.mapAttrsToList
            (name: setOrProto: {
              path = path ++ [name];
              inherit setOrProto;
            })
            setOrProto)
        else [];
      gens = collect {setOrProto = set;};
    in
      gens;

    materialize = mapper: sets: let
      wrap = {
        path,
        value,
        ...
      }: {
        inherit path;
        update = _: value;
      };
      buildAttrSet = updates: lib.updateManyAttrsByPath updates {};
    in
      lib.pipe sets [
        (lib.sort (a: b: (lib.length a.outerPath) < (lib.length b.outerPath)))
        (map mapper)
        (lib.flatten)
        (lib.filter ({
          use ? true,
          value,
          ...
        }:
          if lib.isFunction use
          then use value
          else use))
        (map wrap)
        buildAttrSet
      ];

    # TODO: replace with sanitize or remove
    instantiate = system:
      lib.mapAttrs (
        _: flakeInput:
          flakeInput.${system} or flakeInput
      );

    # root = args.root;
    # systems = self.root.__reflect.finalFlake.config.systems or ["aarch64-darwin" "aarch64-linux" "x86_64-darwin" "x86_64-linux"];
    # nixpkgs = self.root.inputs.nixpkgs or args.nixpkgs;
    capacitor = inputs.self.lib.capacitor;
    defaultPlugins = self.capacitor.plugins.importers.all;

    capacitate = {
      nixpkgs ? null,
      systems ? null,
      overlay ? null,
      flakePath ? [],
    }:
    # arguments to the flake
    flakeArgs:
    # flake function
    mkFlake: let
      context = {
        # The final flake as seen by other flakes and the cli
        self = flakeArgs.self;

        /*
        Library functions from
        - nixpkgs.lib
        - capacitor.lib
        - [input <: all flake inputs | input.lib]

        Shared BY ALL PROTO-X in the same flake.
        */
        lib =
          lib
          // (builtins.mapAttrs (n: v: v.lib or {}) (context.inputs or {}))
          // {capacitor = args.self.lib.capacitor;};

        /*
        The nixpkgs pacakge set.
        This is the base package set, from which all packages shall base upon.

        This value is shared BY ALL FLAKES,
        either included via `config.projects` or `context.capacitated.*`

        If the root flake defines `nixpkgs` explicitly, this set is used.
        Otherwise, the `nixpkgs` input of capacitor is used.

        Note: if used through floxpkgs, floxpkgs takes responsibility
              to the correct nixpkgs
        */
        nixpkgs =
          if nixpkgs != null # passed by parent flake
          then nixpkgs
          else
            flakeArgs.nixpkgs # root flake's `nixpkgs` input
            or args.nixpkgs; # capacitor's `nixpkgs` input

        /*
        The systems that all packages will be provided for.

        Can be overridden through

        ```nix
        # file: flake.nix
        capacitor args (context: {
          config.systems = [ <systems> ... ];
        })
        ```

        in the _root flake's_ definition.

        This value is shared BY ALL FLAKES,
        */
        systems =
          if systems != null
          then systems
          else finalFlake.config.systems or ["aarch64-darwin" "aarch64-linux" "x86_64-darwin" "x86_64-linux"];

        /*
        An automatically managed overlay applied on top of nixpkgs to provide a
        single package set namespace.
        Combines the package sets of all imported flakes.

        Flakes can be imported through

        ```nix
        # file: flake.nix
        capacitor args (context: {
          config.projects = {
            inherit (context.inputs) my-flake;
          };
        })
        ```

        Transitive imports are included recursively.
        */
        # overlay is null for the root flake
        # the root flake uses compose to flatten the input graph
        # this produces an overlay that is passed to the children via the context
        overlay = system:
          if overlay != null
          then overlay system
          else self.capacitor.plugins.compose.overlay context;

        /*
        The inputs as defined in the flakes `flake.nix`
        Includes `self` - a reference to the evalauted flake.
        */
        inputs = flakeArgs;

        /*
        The inputs as defined in the flakes `flake.nix`
        ! evaluated with the shared package set.

        Requires potential rebuilds of attributes that are originally built with
        a different set of packages.
        */
        capacitated =
          lib.mapAttrs (
            name: flake:
              if flake ? __reflect.recapacitate
              then
                flake.__reflect.recapacitate {
                  inherit (context) systems nixpkgs;
                  overlay =
                    # TODO: pass overlay to all capacitated sources
                    if (context.config.projects or {}) ? ${name}
                    then context.overlay
                    else null;
                  flakePath = context.flakePath ++ [name];
                }
              else let
                flakePathStr = lib.showAttrPath context.flakePath;
              in
                throw "(${flakePathStr}): Input `${name}` is not a capacitated flake or uses an incompatible version of capacitor"
          )
          flakeArgs;

        # probably deprecated
        auto = capacitate.auto args;

        # internal
        config =
          {
            nixpkgs-config = {};
            projects = {};
          }
          // (finalFlake.config or {});

        /*
        The sequence fo flakes if transitively imported
        */
        # internal
        flakePath = flakePath;

        /*
        closures:: type -> [closure]

        function to list all closures of a `type`, e.g. `pacakges` or `lib`, ...
        */
        # internal
        closures = type: lib.flatten (map (self.protoToClosure context) (self.collectProtos (finalFlake.${type} or {})));

        /*
        A function to call files with `context`
        */
        callPackageWith = auto: fn: extra: lib.callPackageWith (context // auto) fn extra;

        # deprecated
        withRev = version:
          builtins.trace ''
            deprecation warning: please use `getRev` from `floxpkgs.lib`.
            Note that it expects src. Eg

                "0.0.0-$${getRev src}"
          ''
          "${version}-r${toString context.self.revCount or "dirty"}";

        /*
        context':: system -> specialized context

        Provides specialized versions of context items (if applicable)
        */
        context' = system: {
          system = system;
          nixpkgs = context.lib.callPackageWith {} context.nixpkgs {
            inherit system;
            config = context.config.nixpkgs-config;
            overlays = [(context.overlay system)];
          };
          self = self.instantiate system flakeArgs.self;

          /*
          inputs as in `context` but with attributes for other systems removed

          context.inputs.<input>.<attribute>.<~~system~~>.*
          */
          # TODO: not recursive
          inputs = lib.mapAttrs (_: input: self.instantiate system input) context.inputs;

          /*
          capacitated as in `context` but with attributes for other systems removed

          context.inputs.<input>.<attribute>.<~~system~~>.*
          */
          capacitated = lib.mapAttrs (_: input: self.instantiate system input) context.capacitated;

          /*
          closures:: type -> [closure']

          function to list all closures of a `type`, e.g. `pacakges` or `lib`, ...
          that are defined for `system`
          */
          # TODO: does not work for systems other than the configured ones
          closures = type: lib.filter (c: c.system == system) (context.closures type);

          /*
          callPackage to call function with with instantiated nixpkgs and context
          */
          callPackageWith = auto: fn: extra: lib.callPackageWith ((context.context' system).nixpkgs // context // (context.context' system) // auto) fn extra;
        };
      };

      originalFlake = mkFlake context;
      finalFlake = context.self.__reflect.finalFlake;

      instantiatedPlugins = let
        updates =
          lib.concatMap (
            plugin: let
              pluginInputs = {
                inherit finalFlake originalFlake context;
              };
              outputs = plugin pluginInputs;
            in
              lib.flatten [outputs]
          ) (
            (
              if originalFlake ? config.plugins
              then originalFlake.config.plugins
              else self.defaultPlugins
            )
            ++ (
              if originalFlake ? config.extraPlugins
              then originalFlake.config.extraPlugins
              else []
            )
          );
      in
        lib.foldl'
        lib.recursiveUpdate
        {}
        ([
            ((originalFlake.passthru or {})
              // {
                protos = builtins.removeAttrs finalFlake ["config" "passthru"];
                __reflect = reflect;
              })
          ]
          ++ updates);

      reflect = lib.foldl' lib.recursiveUpdate (originalFlake.config or {}) [
        {
          # systems = self.systems;
          context = context;
          config = context.config;
          recapacitate = root-config: capacitate.capacitate.capacitate root-config flakeArgs mkFlake;
        }
        {
          # Both originalFlake and final Flake refer to the flake definition passed to `capacitate`
          # `originalFlake` is the flake as initially passed in
          # `finalFlake` may be altered by a plugin to inject additional composed content
          #
          #  A plugin like this could inject a locally sourced lib tree:
          #
          #  (_: context: _: {
          #    path = ["__reflect" "finalFlake" "lib" "capacitor"];
          #    value = _: context.auto.localResourcesWith {root = root;} "lib" context "lib/";
          #  })
          #
          originalFlake = originalFlake;
          finalFlake = originalFlake;
        }
        {
          inherit
            (self)
            compose
            ;
          # inherit
          # composeSelfWith
          # composeSelf
          # ;
        }
      ];
    in
      instantiatedPlugins;
  }
