{
  lib,
  inputs,
}: let
  args = inputs;
  capacitate = lib.capacitor.capacitate;
  self = capacitate.capacitate;
in
  ###
  # Closure:
  # Metadata attached to a proto* function.
  # Capacitor enumerates all proto* functions in a flake
  # and adds additional data to them.
  # Evaluating the closures means evaluating the proto* function
  # with a standardized context that is a superset of the closure.
  #
  # closure:: {
  #   system,         # the system the closure is defined for
  #   flakePath,      # path to the flake in the import graph
  #   isCapacitated,  # whether the closure was generated by capacitor (const = true)
  #   type,           # the proto type (const = "proto")
  #   outerPath       # attrpath of the original proto
  #   fn              # the proto function
  #   outputType      # the anticipated type of the proto (generally, the flake attribute)
  #   namespace       # the normalized attribute path of the proto value after evaluation
  #   value           # the value for the proto* function after evaluation with `context`
  # }
  #
  # Context:; closure âˆª {
  #   lib = lib // self.root.lib;
  #   args            # arguments to the flake
  #   args'
  #   inputs = args';
  #   self' = self.instantiate system flakeArgs.self;
  #   self = flakeArgs.self;
  #   root =  self.root;
  #   root' = self.rootWith system;
  #   nixpkgs' = self.nixpkgsWith system;
  #   nixpkgs = self.nixpkgs;
  #   pkgs = self.nixpkgsWith system;
  #   withRev = version: "${version}-r${toString flakeArgs.self.revCount or "dirty"}";
  # }
  #
  #
  ###
  {
    protoToClosure = {
      systems,
      flakePath ? [],
      # outputType,
      ...
    } @ defaults: {
      type,
      isCapacitated,
      outerPath,
      fn,
    } @ closure: let
      hasSystem =
        if lib.length outerPath == 0
        then false
        else lib.elem (lib.head outerPath) lib.platforms.all;
      namespace =
        if lib.length outerPath == 0 || (hasSystem && lib.length outerPath == 1)
        then ["default"]
        else if hasSystem
        then (lib.tail outerPath)
        else outerPath;

      # if has System only use the specified one
      # else instantiate for all systems
      systems =
        if hasSystem
        then [(lib.head outerPath)]
        else defaults.systems;

      systemlessClosure =
        closure
        // {
          inherit namespace flakePath;
          # inherit outputType;
        }
        // {
          fn = {
            __toString = self: "<<Proto Derivation>>";
            __functor = self: closure.fn;
          };
        };

      closuresForEachSystem =
        map
        (system: systemlessClosure // {inherit system;})
        systems;
    in
      if systems != []
      then closuresForEachSystem
      else [systemlessClosure];

    collectProtos = set: let
      collect = {
        path ? [],
        setOrProto,
      }:
      # [sic]
        if builtins.isFunction setOrProto
        then [
          {
            type = "proto";
            isCapacitated = true;
            outerPath = path;
            fn = setOrProto;
          }
        ]
        else if lib.isAttrs setOrProto
        then
          lib.concatMap collect
          (lib.mapAttrsToList
            (name: setOrProto: {
              path = path ++ [name];
              inherit setOrProto;
            })
            setOrProto)
        else [];
      gens = collect {setOrProto = set;};
    in
      gens;

    #     # TODO: call with callPackage assumably
    #     output = fn originalArgs;

    #     isProto = lib.isDerivation output; #.value;
    #     value = output; #= (if output.success then output.value else {});
    #     value' =
    #       if isProto && !(value ? proto)
    #       then value // {proto = fn;}
    #       else value;

    #     evaluatedClosure =
    #       closure
    #       // {
    #         originalArgs = originalArgs;
    #         output = output;
    #         value = value';
    #         isProto = isProto;
    #       };
    #   in
    #     evaluatedClosure;

    generateProtos = configuration: set: let
      protoToClosure = self.protoToClosure configuration;
    in
      lib.pipe set [
        (self.collectProtos)
        (lib.concatMap protoToClosure)
      ];

    generate = set: configuration: flakeArgs:
      map (self.evaluateClosure flakeArgs) (self.generateProtos configuration set);

    generateProjects = outputType: {
      flakePath,
      systems,
    } @ defaultConfiguration: projects: flakeArgs: let
      makeProject = name: project: let
        project' = capacitate (defaultConfiguration // {flakePath = flakePath ++ [name];});
      in
        project';
    in
      (lib.mapAttrs makeProject) projects;

    materialize = mapper: sets: let
      wrap = {
        path,
        value,
        ...
      }: {
        inherit path;
        update = _: value;
      };
      buildAttrSet = updates: lib.updateManyAttrsByPath updates {};
    in
      lib.pipe sets [
        (lib.sort (a: b: (lib.length a.outerPath) < (lib.length b.outerPath)))
        (map mapper)
        (lib.flatten)
        (lib.filter ({
          use ? true,
          value,
          ...
        }:
          if lib.isFunction use
          then use value
          else use))
        (map wrap)
        buildAttrSet
      ];

    # TODO: replace with sanitize or remove
    instantiate = system:
      lib.mapAttrs (
        _: flakeInput:
          flakeInput.${system} or flakeInput
      );

    # root = args.root;
    # systems = self.root.__reflect.finalFlake.config.systems or ["aarch64-darwin" "aarch64-linux" "x86_64-darwin" "x86_64-linux"];
    # nixpkgs = self.root.inputs.nixpkgs or args.nixpkgs;
    capacitor = inputs.self.lib.capacitor;
    defaultPlugins = self.capacitor.plugins.importers.all;

    capacitate = {
      nixpkgs ? null,
      systems ? null,
      overlay ? null,
      flakePath ? [],
    }:
    # arguments to the flake
    flakeArgs:
    # flake function
    mkFlake: let
      context = {
        lib =
          lib
          // ( builtins.mapAttrs (n: v: v.lib or {}) (context.inputs or {}) )
          // { capacitor = args.self.lib.capacitor; };
        flakePath = flakePath;
        systems =
          if systems != null
          then systems
          else finalFlake.config.systems or ["aarch64-darwin" "aarch64-linux" "x86_64-darwin" "x86_64-linux"];

        self = flakeArgs.self;
        # use root flake eplicitly defined nixpkgs or fall back to capacitor's
        nixpkgs =
          if nixpkgs != null
          then nixpkgs
          else flakeArgs.nixpkgs or args.nixpkgs;
        # overlay is null for the root flake
        # the root flake uses compose to flatten the input graph
        # this produces an overlay that is passed to the children via the context
        # TODO: refactor compose to take this context
        # TODO: refactor plugin
        overlay = system:
          if overlay != null
          then overlay system
          else self.capacitor.plugins.compose.overlay context;

        inputs = flakeArgs;
        capacitated =
          lib.mapAttrs (
            name: flake:
              if flake ? __reflect.recapacitate
              then
                flake.__reflect.recapacitate {
                  inherit (context) systems nixpkgs;
                  overlay =
                    # TODO: pass overlay to all capacitated sources
                    if (context.config.projects or {}) ? ${name}
                    then context.overlay
                    else null;
                  flakePath = context.flakePath ++ [name];
                }
              else throw "(${lib.showAttrPath context.flakePath}): Input `${name}` is not a capacitated flake or uses an incompatible version of capacitor"
          )
          flakeArgs;

        auto = capacitate.auto args;
        config =
          {
            nixpkgs-config = {};
            projects = {};
          }
          // (finalFlake.config or {});

        closures = type: lib.flatten (map (self.protoToClosure context) (self.collectProtos (finalFlake.${type} or {})));

        callPackageWith = auto: fn: extra: lib.callPackageWith (context // auto) fn extra;

        withRev = version:
          builtins.trace ''
            deprecation warning: please use `getRev` from `floxpkgs.lib`.
            Note that it expects src. Eg

                "0.0.0-$${getRev src}"
          ''
          "${version}-r${toString context.self.revCount or "dirty"}";

        context' = system: {
          system = system;
          nixpkgs = context.lib.callPackageWith {} context.nixpkgs {
            inherit system;
            config = context.config.nixpkgs-config;
            overlays = [(context.overlay system)];
          };
          self = self.instantiate system flakeArgs.self;
          # TODO: not recursive
          inputs = lib.mapAttrs (_: input: self.instantiate system input) context.inputs;
          capacitated = lib.mapAttrs (_: input: self.instantiate system input) context.capacitated;
          # TODO: does not work for systems other than the configured ones
          closures = type: lib.filter (c: c.system == system) (context.closures type);
          callPackageWith = auto: fn: extra: lib.callPackageWith ((context.context' system).nixpkgs // context // (context.context' system) // auto) fn extra;
        };
      };

      originalFlake = mkFlake context;
      finalFlake = context.self.__reflect.finalFlake;

      instantiatedPlugins = let
        updates =
          lib.concatMap (
            plugin: let
              pluginInputs = {
                inherit finalFlake originalFlake;
                context = context;
                # // { self = (instantiatedPlugins // {outPath = (flakeArgs.self.sourceInfo.outPath);} ); };
                capacitate = {
                  # inherit composeSelf composeSelfWith;
                };
              };
              outputs = plugin pluginInputs;
            in
              lib.flatten [outputs]
          ) (
            (
              if originalFlake ? config.plugins
              then originalFlake.config.plugins
              else self.defaultPlugins
            )
            ++ (
              if originalFlake ? config.extraPlugins
              then originalFlake.config.extraPlugins
              else []
            )
          );
      in
        lib.foldl'
        lib.recursiveUpdate
        {}
        ([((originalFlake.passthru or {}) // {
          protos = builtins.removeAttrs finalFlake ["config" "passthru"];
          __reflect = reflect;
          })] ++ updates);

      reflect = lib.foldl' lib.recursiveUpdate (originalFlake.config or {}) [
        {
          # systems = self.systems;
          context = context;
          config = context.config;
          recapacitate = root-config: capacitate.capacitate.capacitate root-config flakeArgs mkFlake;
        }
        {
          # Both originalFlake and final Flake refer to the flake definition passed to `capacitate`
          # `originalFlake` is the flake as initially passed in
          # `finalFlake` may be altered by a plugin to inject additional composed content
          #
          #  A plugin like this could inject a locally sourced lib tree:
          #
          #  (_: context: _: {
          #    path = ["__reflect" "finalFlake" "lib" "capacitor"];
          #    value = _: context.auto.localResourcesWith {root = root;} "lib" context "lib/";
          #  })
          #
          originalFlake = originalFlake;
          finalFlake = originalFlake;
        }
        {
          inherit
            (self)
            compose
            ;
          # inherit
          # composeSelfWith
          # composeSelf
          # ;
        }
      ];
    in
      instantiatedPlugins;
  }
